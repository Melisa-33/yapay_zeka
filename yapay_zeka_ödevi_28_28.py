# -*- coding: utf-8 -*-
"""yapay_zeka_ödevi_28*28.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W4pj70PssRmK1slcjKQDSL3JDAAkYNdS
"""

#28*28
import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import datasets, transforms
import matplotlib.pyplot as plt

# Hiperparametreler
batch_size = 64         # aynı anda modele 64 tane resim yolla
learning_rate = 0.001   # ağırlıkları ne kadar hızlı değiştirelim ?
num_epochs = 5          # tüm verisetini kaç defa baştan sona gezeyim

# Veri Ön İşleme ve Yükleme
transform = transforms.Compose([
    transforms.ToTensor(),                # değerleri 0-1 aralığına çek
    transforms.Normalize((0.5,), (0.5,))  # verileri standart hale getir mean=0.5 std=0.5
])

train_dataset = datasets.MNIST(root='./data', train=True, transform=transform, download=True)
test_dataset = datasets.MNIST(root='./data', train=False, transform=transform, download=True)

train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=True)
test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=False)

# Sequential Kullanarak CNN Model Tanımı
class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        # Konvolüsyonel katmanlar ve MaxPooling katmanları
        self.features = nn.Sequential(
            nn.Conv2d(1, 6, kernel_size=5, padding=2),    # Konvolüsyon Katmanı (1 kanal => 6 kanal)
            nn.ReLU(),                                   # Aktivasyon
            nn.MaxPool2d(kernel_size=2, stride=2),        # Havuzlama Katmanı

            nn.Conv2d(6, 16, kernel_size=5),              # Konvolüsyon Katmanı (6 kanal => 16 kanal)
            nn.ReLU(),                                   # Aktivasyon
            nn.MaxPool2d(kernel_size=2, stride=2),        # Havuzlama Katmanı
        )

        self.siniflandirici = nn.Sequential(
            nn.Flatten(),
            nn.Linear(16 * 5 * 5, 120),  # 16 * 5 * 5 = 400'ü kullanıyoruz
            nn.ReLU(),
            nn.Dropout(p=0.5),  # Dropout
            nn.Linear(120, 84),
            nn.ReLU(),
            nn.Dropout(p=0.5),  # Dropout
            nn.Linear(84, 10),   # Çıkış katmanı (10 sınıf)
        )

    def forward(self, x):
        x = self.features(x)
        x = self.siniflandirici(x)
        return x

# Model, Kayıp Fonksiyonu, Optimizasyon
model = SimpleCNN()
criterion = nn.CrossEntropyLoss()                            # hata miktarını hesapla
optimizer = optim.Adam(model.parameters(), lr=learning_rate) # ağırlıkları güncelleyen optimizer

# Eğitim Döngüsü
def train(model, train_loader, criterion, optimizer, num_epochs):
    for epoch in range(num_epochs):
        model.train()     # modeli eğitim moduna al
        total_loss = 0
        for batch_idx, (data, target) in enumerate(train_loader):
            optimizer.zero_grad()             # optimizer sıfırla
            output = model(data)              # modele 64 resim ver
            loss = criterion(output, target)  # hata hesapla
            loss.backward()                   # geri yayılım
            optimizer.step()                  # ağırlıkları güncelle
            total_loss += loss.item()         # toplam kaybı biriktir

        # Eğitim kaybını yazdır
        print(f"Epoch {epoch+1}/{num_epochs}, Loss: {total_loss / len(train_loader):.4f}")

# Test Döngüsü
def test(model, test_loader):
    model.eval()        # modeli test moduna al
    correct = 0
    total = 0
    with torch.no_grad():  # model türev hesaplamasın
        for data, target in test_loader:
            output = model(data)
            pred = output.argmax(dim=1, keepdim=True)  # tahmini sınıf
            correct += pred.eq(target.view_as(pred)).sum().item()
            total += target.size(0)

    accuracy = correct / total
    print(f"Test Accuracy: {accuracy * 100:.2f}%")

# Eğitim ve Test
train(model, train_loader, criterion, optimizer, num_epochs)
test(model, test_loader)

# Testten bazı görüntüler ve tahminlerini görselleştir
def plot_predictions(model, test_loader):
    model.eval()
    data, labels = next(iter(test_loader))  # Test verisinden bir batch al
    output = model(data)
    preds = output.argmax(dim=1, keepdim=True)

    #plt.figure(figsize=(10, 10))
    #for i in range(9):
        #plt.subplot(3, 3, i + 1)
        #plt.imshow(data[i][0], cmap='gray')
        #plt.title(f"Pred: {preds[i].item()}, True: {labels[i].item()}")
        #plt.axis('off')
    #plt.show()

# Test setinden rastgele örneklerle tahminleri görselleştir
#plot_predictions(model, test_loader)